[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":"/articles/tuning-parameters.html","id":"tuning-parameters","dir":"Articles","previous_headings":"","what":"Tuning Parameters","title":"Tuning Block-Length Selection Methods","text":"section discuss tuning parameters optimization method. Though parameters set default, often times manual inspection adjustments need made identify remedy problematic solutions local optima corner solutions. overview tuning parameters: sub_sample pilot_block_length K_N M_max m_hat b_max c","code":""},{"path":"/articles/tuning-parameters.html","id":"hhj","dir":"Articles","previous_headings":"Tuning Parameters","what":"HHJ","title":"Tuning Block-Length Selection Methods","text":"accuracy hhj() depends choice two tuning parameters. first size subsample series perform cross-validation . argument sub_sample, parameter mm Hall, Horowitz, Jing (1995). stage mm unknown, restrictions mm must follow. Note hhj() computationally intensive procedure may take time, especially length series becomes large. Employing parallelization adjusting grid search parameters streamline search process may help. Since hhj() must iterate multiple subsamples must m<nm < n nn length series provided argument series, .e. length(series). specifically, must m−1+n−1m=o(1) n→∞. m^{-1} + n^{-1}m  = o(1) \\text{ } n \\rightarrow \\infty \\ . default, sub_sample = NULL sets m=n1/5*n1/km = n^{1 / 5} * n^{1 / k} satisfying restrictions. Users can override directly setting mm numeric constant supplied subsample. Ideally, mm integer, hhj() round whole number automatically. Though mm almost entirely arbitrary, second tuning parameter hhj() less . pilot_block_length argument, parameter ll Hall, Horowitz, Jing (1995) also denoted ln*l^{*}_n Lahiri (2003) treatment. pilot_block_length block-length used perform initial block-bootstrap series. reduce effect choice ll accuracy optimization, hhj() replaces ll previous iteration’s estimate optimal block-length l*l^* (ln0̂\\hat{l^0_n} Lahiri (2003)), repeating convergence iteration limit implied n_iter reached. number supplied pilot_block_length used first iteration hhj() hence referred pilot parameter. practice, hhj() estimates l*l^* minimizing MSEMSE function possible block-length using block-bootstrap subsample series length m.m. block-length minimizes MSEMSE given subsample used estimate l*l^* replaces pilot_block_length next iteration. However, minimize MSEMSE subsample length mm, must first scale block-length back original series length n.n. accomplished employing Richardson Extrapolation, sequence acceleration technique numerical analysis first developed 1911, see Richardson Glazebrook (1911). sense, hhj() actually estimates optimal block-length subsample l̂m\\hat{l}_m scaled full series l=l̂m(n/m)1/k,wherek={3,4,5},l = \\hat{l}_m (n/m)^{1/k}, \\ \\text{} \\ k = \\{3, 4, 5\\} \\ , kk depends context object estimation.","code":""},{"path":"/articles/tuning-parameters.html","id":"pwsd","dir":"Articles","previous_headings":"Tuning Parameters","what":"PWSD","title":"Tuning Block-Length Selection Methods","text":"Like hhj(), accuracy pwsd() also subject somewhat arbitrary choice tuning parameters. Unlike HHJ method, however, tuning parameters pwsd() deal exclusively way method adapts underlying correlation structure series whereas hhj(), tuning parameters set lengths sizes cross-validate subsamples. Note pwsd() set tuning parameters recommended defaults argument data must supplied. Politis White (2004) discuss proposed defaults techniques adjust tuning parameters largely footnote c page 59. first tuning parameter pwsd() K_N, denoted KNK_N Politis White (2004). K_N takes integer value indicates maximum number lags apply implied hypothesis test correlogram series. , K_N number consecutive lags correlogram must appear insignificant order select optimal bandwidth MM flat-top lag window. Politis White (2004) suggest letting M=2m̂M = 2\\hat{m} m̂\\hat{m} smallest positive integer following K_N consecutive lags appear insignificant respect level significance, discussed later. default, K_N  = NULL sets KN=max(5,⌈log10N⌉)K_N = max(5, \\lceil \\ \\log_{10}N \\ \\rceil) per suggestion Politis White (2004). Note KNK_N must non-decreasing integer valued function NN KN=o(log10N)K_N = o(\\log_{10}N) NN length series supplied data =, .e. nrow(data). next tuning parameter M_max (denoted MmaxM_{max} ) acts upper-bound MM 2*m̂>Mmax⇒M=Mmax.2 * \\hat{m} > M_{max} \\Rightarrow M = M_{max} \\ . Thus, M_max allows us expand contract maximum size bandwidth flat-top lag windows Politis Romano (1995). case 2*m̂<Mmax2 * \\hat{m} < M_{max}, changing value M_max affect method’s accuracy. can inspect output pwsd() assess interim values may help us understand tune calculation. example, can find value estimated m̂\\hat{m} inspecting $parameters component pwsd() output objects, .e. objects class = \"pwsd\". show lets first housekeeping attach blocklength. Now, generate stationary AR(1)AR(1) time series select optimal block-length using PWSD method: can see m_hat = 3 M_max = 28 censoring occurring. certain situations, may wish forego implied hypothesis test estimate m_hat instead set m_hat directly supplying integer pwsd(m_hat = ). general, implied hypothesis test used unless specific characteristics known data-generating process underlying series issues correlogram output present. next tuning parameter b_max = acts upper-bound optimal block-length. can extracted ‘pwsd’ class objects using $BlockLength. pwsd() estimates value optimal block-length b_Stationary > b_max b_Circular > b_max b_Stationary/b_Circular set b_max. default, b_max = NULL sets b_max = ceiling(min(3 * sqrt(n), n / 3)). can inspect output pwsd() see selected block-lengths censored b_max. can see optimal block-length 8 9 observations long. far default maximum value 68. final tuning parameter pwsd() argument c also denoted cc Politis White (2004). high-level cc acts pseudo confidence-level conduct implied hypothesis tests series’ correlogram. Thus, must c>0.c > 0. auto-correlation given lag kk critical value ρcritical\\rho_{critical}, lag considered significant. critical value defined ρcritical=clog10N/N.\\rho_{critical} = c\\sqrt{\\log_{10}N / N}. Politis White (2004) suggest value c=2c = 2 default, pwsd() treats cc standard two-tailed 95% confidence interval setting c = qnorm(0.975). quite close suggested value 2. Using correlogram output, either setting correlogram = TRUE using corresponding plot method, can visualize ρcritical\\rho_{critical} dashed magenta lines form significance bands plot.","code":"library(blocklength) set.seed(32) # Generate an AR(1) simulation sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Run the PWSD method and suppress output of the correlogram b <- pwsd(sim, correlogram = FALSE)  # Inspect interim parameters b$parameters #>        n k        c K_N M_max b_max m_hat M rho_k_critical #> [1,] 500 1 1.959964   5    28    68     3 6      0.1439999 # Print block-length estimates b$BlockLength #>      b_Stationary b_Circular #> data     9.327923   10.67781  # Test if optimal block-length is censored by b_max b$parameters[, \"b_max\"] == b$BlockLength #>      b_Stationary b_Circular #> data        FALSE      FALSE  # Print the upper-bound b$parameters[, \"b_max\"] #> b_max  #>    68 # Print rho_k_critical b$parameters[, \"rho_k_critical\"] #> rho_k_critical  #>      0.1439999  # Plot correlogram from previous selection plot(b, main = \"c = qnorm(0.975)\", ylim = c(-0.2, 1))  # Expand confidence level and plot again b1 <- pwsd(sim, c = 4, correlogram = FALSE) plot(b1, main = \"c = 4\", ylim = c(-0.2, 1))"},{"path":"/articles/tuning-parameters.html","id":"diagnosing-problematic-solutions","dir":"Articles","previous_headings":"","what":"Diagnosing Problematic Solutions","title":"Tuning Block-Length Selection Methods","text":"Problematic solutions can render block-length selections unreliable inconsistent, thus important inspect interim output MSEMSE function hhj() respective Correlogram output pwsd().","code":""},{"path":"/articles/tuning-parameters.html","id":"hhj-1","dir":"Articles","previous_headings":"Diagnosing Problematic Solutions","what":"HHJ","title":"Tuning Block-Length Selection Methods","text":"plots = TRUE MSEMSE function plotted output console iteration algorithm. plots = FALSE, interim output suppressed; however, users can save output hhj() access plots later using corresponding S3 plot method, just like plotted output pwsd() . main issues occur hhj() optimization method solving local minima corner solutions MSEMSE function. Ideally, MSEMSE plot exhibit convex shape, plot depicted :  However, often times case MSEMSE plot may appear concave. example problematic MSEMSE plot illustrated .  see MSEMSE function minimized taking largest block-length available, case 25. problematic may larger block-length truly optimal. evaluated MSEMSE larger range possible block-lengths, may captured. Similarly, may smallest (leftmost) block-length found minimize MSEMSE function. main issue concavity. plots often indicate solution reached local minimum, changing tuning parameters hhj() likely lead new equally unreliable estimate. cases, may help shrink sub_sample size, m.m. discussed previously choice pilot_block_length less important users encouraged try range combinations tuning parameters. may case permutation pilot_block_length sub_sample produce convex MSEMSE plot. situation, users encouraged benchmark results hhj() methods provided package.","code":"# Select a block-length using HHJ method b2 <- hhj(sim, sub_sample = 10, k = \"bias/variance\", plots = FALSE) #>  Pilot block length is: 3 #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 10 function evaluations required. #>  Chosen block length: 11  After iteration: 1 #>  Converged at block length (l): 11 plot(b2) # Generate a AR(2) simulation sim2 <- stats::arima.sim(list(order = c(2, 0, 0), ar = c(0.5, 0.3)),                         n = 500, innov = rnorm(500))  # Select a block-length using HHJ method b3 <- hhj(sim2, plots = FALSE) #>  Pilot block length is: 3 #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 12 function evaluations required. #>  Chosen block length: 25  After iteration: 1 #>  Converged at block length (l): 25 plot(b3)"},{"path":"/articles/tuning-parameters.html","id":"pwsd-1","dir":"Articles","previous_headings":"Diagnosing Problematic Solutions","what":"PWSD","title":"Tuning Block-Length Selection Methods","text":"Politis White (2004) explicit manual inspection correlogram necessary, especially cases m̂,\\hat{m}, subsequently optimal block-length b̂opt,\\hat{b}_{opt}, large. looking correlogram significance bands corresponding ±clog10N/N,\\pm \\  c\\sqrt{\\log_{10}{N}/N}, can asses sensitive selection m̂\\hat{m} tuning parameters. Specifically, Politis White (2004) define m̂\\hat{m} smallest integer correlogram remains within significance bands least KNK_N lags lag m̂.\\hat{m}. illustrate , consider problematic correlogram arising AR(1)AR(1) simulation 500 observations ρ=0.3,\\rho = 0.3 \\ , named pcorr code . Note pcorr loaded behind scenes randomly generated time vignette built.  follow Politis White (2004) rule estimating m̂\\hat{m} explicitly KN=5K_N = 5, must m̂=3\\hat{m} = 3 3 smallest lag kk following 5 lags insignificant (within dashed bands). adjust cc KNK_N slightly re-estimate m̂\\hat{m} radically different. example keep cc default qnorm(0.975) change KN=6,K_N = 6, led m̂=9.\\hat{m} = 9.  Alternatively, keep KN=5K_N = 5 change cc mimic 99% confidence level setting c = qnorm(0.995), get following output much wider bands significance:  can see moving significance bands farther apart changes estimation m̂=1.\\hat{m} = 1. Overall, sensitivity m̂\\hat{m} tuning parameters concerning users proceed vigilance. default tuning parameters pwsd() merely suggestions, Politis White (2004) provide rule--thumb users faced problematic solutions correlograms presented . recommend users always take account experience knowledge data set -hand, also note flat-top lag window spectral estimators preform best small values MM users favor smallest simple model complex model similar explanatory power. light, Politis White (2004) recommend setting m̂=1\\hat{m} = 1 presence unclear correlogram lack reasonable intuition. Note pwsd() automatically set m̂=1\\hat{m} = 1 significant lags correlogram. accomplish manually, can set M_max = 1 force m̂=1.\\hat{m} = 1. However, knowledge underlying data-generating process known, may want lean intuition. example, benchmark interest rates often derived daily interest rate using 30-day (90-day) compound average. circumstances, may want examine least 30 (90) lags correlation structure consider completely overriding estimation m̂\\hat{m} setting argument m_hat = 30 m_hat = 90.","code":"# Select a block-length using PWSD method b4 <- pwsd(pcorr, K_N = 5, correlogram = FALSE) plot(b4, main = \"Problematic Correlogram\")  # Output m_hat to console b4$parameters[, \"m_hat\"] #> m_hat  #>     3 # Select block-length using PWSD method b5 <- pwsd(pcorr, K_N = 6, correlogram = FALSE) plot(b5, main = \"Problematic Correlogram 2\")  # Output m_hat to console b5$parameters[, \"m_hat\"] #> m_hat  #>     9 # Select a block-length using PWSD method b6 <- pwsd(pcorr, c = qnorm(0.995), correlogram = FALSE) plot(b6, main = \"Problematic Correlogram 3\")  # Output m_hat to console b6$parameters[, \"m_hat\"] #> m_hat  #>     1"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alec Stashevsky. Author, maintainer. Sergio Armella. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Stashevsky (2025). blocklength: Select Optimal Block-Length Bootstrap Dependent Data (Block Bootstrap). R package version 0.2.0, https://github.com/Alec-Stashevsky/blocklength, https://alecstashevsky.com/r/blocklength.","code":"@Manual{,   title = {blocklength: Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)},   author = {Alec Stashevsky},   year = {2025},   note = {R package version 0.2.0, https://github.com/Alec-Stashevsky/blocklength},   url = {https://alecstashevsky.com/r/blocklength}, }"},{"path":"/index.html","id":"blocklength-","dir":"","previous_headings":"","what":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"blocklength R package used automatically select block-length parameter block-bootstrap. meant use dependent data stationary time series.","code":""},{"path":"/index.html","id":"the-story","dir":"","previous_headings":"","what":"The Story","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"Regular bootstrap methods rely assumptions observations independent identically distributed (..d.), assumption fails many types time series expect observation previous period explanatory power current observation. occur time series unemployment rates, stock prices, biological data, etc. time series ..d. look like white noise, since following observation totally independent previous one (random). get around problem, can retain time-dependence breaking-time series number blocks length l. Instead sampling observation randomly (replacement) like regular bootstrap, can resample blocks random. way within block time-dependence preserved. problem block bootstrap high sensitivity choice block-length, number blocks break time series . goal blocklength simplify automate process selecting block-length perform bootstrap dependent data. blocklength several functions take name authors proposed . Currently, three methods available: hhj() takes name Hall, Horowitz, Jing (1995) “HHJ” method select optimal block-length using cross-validation algorithm minimizes mean squared error (MSE) incurred bootstrap various block-lengths. pwsd() takes name Politis White (2004) Spectral Density “PWSD” Plug-method automatically select optimal block-length using spectral density estimation via “flat-top” lag windows Politis Romano (1995). nppi() takes name Lahiri, Furukawa, Lee (2007) Nonparametric Plug-“NPPI” method select optimal block-length block bootstrap procedures. NPPI method estimates leading term first-order expansion theoretically optimal block length using resampling methods construct consistent bias variance estimators block-bootstrap. Specifically, package implements Moving Block Bootstrap (MBB) method Künsch (1989) Moving Blocks Jackknife (MBJ) Liu Singh (1992). bias variance estimators, respectively. hood, hhj() uses moving block bootstrap (MBB) procedure according Künsch (1989) resamples blocks set overlapping sub-samples fixed block-length. However, results hhj() may generalized block bootstrap procedures stationary bootstrap Politis Romano (1994). Compared pwsd(), hhj() computationally intensive relies iterative sub-sampling processes optimize MSE function possible block-length (select grid block-lengths), pwsd() simpler “plug-” rule uses auto-correlations, auto-covariance, spectral density series optimize choice block-length. Similarly, nppi() another “plug-” rule, however, due heavy reliance resampling, can also computationally intensive compared pwsd(). detailed comparison, see table : * algorithms default user-defined parameters recomended respective authors.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"can install released version CRAN : can install development version GitHub :","code":"install.packages(\"blocklength\") # install.packages(\"devtools\") devtools::install_github(\"Alec-Stashevsky/blocklength\")"},{"path":"/index.html","id":"use-case","dir":"","previous_headings":"","what":"Use Case","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"want select optimal block-length perform block bootstrap simulated autoregressive AR(1) time series. First generate time series: Now, can find optimal block-length perform block-bootstrap. using three available methods.","code":"library(blocklength)  # Simulate AR(1) time series series <- stats::arima.sim(model = list(order = c(1, 0, 0), ar = 0.5),                            n = 500, rand.gen = rnorm)  # Coerce time series to data.frame (not necessary) data <- data.frame(\"AR1\" = series)"},{"path":"/index.html","id":"id_1-the-hall-horowitz-and-jing-1995-hhj-method","dir":"","previous_headings":"Use Case","what":"1. The Hall, Horowitz, and Jing (1995) “HHJ” Method","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"","code":"## Using the HHJ Algorithm with overlapping subsamples of width 10 hhj(series, sub_sample = 10, k = \"bias/variance\") #>  Pilot block length is: 3 #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 10 function evaluations required. #>  Chosen block length: 11  After iteration: 1 #>  Converged at block length (l): 11 #> $`Optimal Block Length` #> [1] 11 #>  #> $`Subsample block size (m)` #> [1] 10 #>  #> $`MSE Data` #>    Iteration BlockLength       MSE #> 1          1           4 0.5428141 #> 2          1           7 0.5159969 #> 3          1          11 0.5058036 #> 4          1          15 0.5101443 #> 5          1          18 0.5173569 #> 6          1          22 0.5285706 #> 7          1          26 0.5307042 #> 8          1          29 0.5459579 #> 9          1          33 0.5596887 #> 10         1          37 0.5536393 #> 11         2           4 0.5404021 #> 12         2           7 0.5165052 #> 13         2          11 0.5083257 #> 14         2          15 0.5096941 #> 15         2          18 0.5099022 #> 16         2          22 0.5251345 #> 17         2          26 0.5297922 #> 18         2          29 0.5411978 #> 19         2          33 0.5595094 #> 20         2          37 0.5541540 #>  #> $Iterations #> [1] 2 #>  #> $Series #> [1] \"series\" #>  #> $Call #> hhj(series = series, sub_sample = 10, k = \"bias/variance\") #>  #> attr(,\"class\") #> [1] \"hhj\""},{"path":"/index.html","id":"id_2-the-politis-and-white-2004-spectral-density-estimation-pwsd-method","dir":"","previous_headings":"Use Case","what":"2. The Politis and White (2004) Spectral Density Estimation “PWSD” Method","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"can see methods produce similar results block-length 9 11 depending type bootstrap method used.","code":"# Using Politis and White (2004) Spectral Density Estimation pwsd(data) #> $BlockLength #>     b_Stationary b_Circular #> AR1     9.327923   10.67781 #>  #> $Acf #> $Acf$AR1 #>  #> Autocorrelations of series 'data[, i]', by lag #>  #>      0      1      2      3      4      5      6      7      8      9     10  #>  1.000  0.550  0.291  0.175  0.107  0.066  0.049  0.010 -0.078 -0.057 -0.071  #>     11     12     13     14     15     16     17     18     19     20     21  #> -0.081 -0.071 -0.097 -0.073 -0.054 -0.010  0.014 -0.030 -0.042 -0.020 -0.073  #>     22     23     24     25     26     27     28  #> -0.088 -0.050 -0.058 -0.097 -0.049  0.021  0.078  #>  #>  #> $parameters #>        n k        c K_N M_max b_max m_hat M rho_k_critical #> [1,] 500 1 1.959964   5    28    68     3 6      0.1439999 #>  #> $Call #> pwsd(data = data) #>  #> attr(,\"class\") #> [1] \"pwsd\""},{"path":"/index.html","id":"id_3-the-lahiri-furukawa-and-lee-2007-nonparametric-plug-in-nppi-method","dir":"","previous_headings":"Use Case","what":"3. The Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In “NPPI” Method","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"","code":"# Using Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In  nppi(data, m = 8)  #>  Setting l to recomended value: 3 #> $optimal_block_length #> [1] 0.1666766 #>  #> $bias #> [1] 0.01152002 #>  #> $variance #> [1] 8.831518e-06 #>  #> $jab_point_values #>   [1] -0.0327374132  0.0086065594  0.0025366424  0.0406465091  0.0406465091 #>   [6]  0.0027838449 -0.0030100569  0.0406465091 -0.0971565707 -0.0371154550 #>  [11] -0.0755599178 -0.0755599178  0.0339749181 -0.0153968136  0.0145322529 #>  [16]  0.0169365682 -0.0333963967 -0.0333963967 -0.0333963967  0.0005655976 #>  [21]  0.0005655976  0.0005655976 -0.0708860990 -0.0270703095 -0.0270703095 #>  [26] -0.0659660916  0.0105882914 -0.0534955263  0.0206597579  0.0206597579 #>  [31] -0.0011544990 -0.0011544990  0.0183578992 -0.0301712541  0.0054632495 #>  [36] -0.0266459338 -0.0054879294  0.0134722464  0.0134722464  0.0449865026 #>  [41]  0.0449865026  0.0449865026  0.0449865026  0.0449865026  0.0100703950 #>  [46] -0.0889593545  0.0310801474 -0.0243945020  0.0152544405 -0.0278311082 #>  [51] -0.0116288527 -0.0320142219 -0.0320142219 -0.0142486081 -0.0052232227 #>  [56] -0.0052232227 -0.0052232227 -0.0276679506  0.0423320598 -0.0917146684 #>  [61] -0.0672953105  0.0678550387 -0.0378347310 -0.0378347310 -0.0818476398 #>  [66] -0.0427210926 -0.0250356679 -0.0250356679  0.0150383573 -0.0180655321 #>  [71] -0.0011544990 -0.0446551570 -0.0994751979 -0.0994751979 -0.0576207962 #>  [76] -0.0396419555 -0.0396419555 -0.0396419555 -0.0003119844 -0.0540061018 #>  [81]  0.0803656842 -0.0528692544 -0.0646321946 -0.0646321946 -0.0402261089 #>  [86] -0.0208329391 -0.0389210110  0.0489710594 -0.0099764121 -0.0355391996 #>  [91] -0.0536628938 -0.0378180773  0.0124084253  0.0124084253 -0.0644349773 #>  [96] -0.0644349773 -0.0644349773 -0.0369211728 -0.0238227629 -0.0238227629 #> [101]  0.0333384171  0.0333384171  0.0140114628  0.0447980697 -0.1019902258 #> [106] -0.0428492854 -0.0142220238 -0.1019902258 -0.1019902258 -0.0835156159 #> [111] -0.0819563010 -0.0819563010 -0.0185758839 -0.0266705165 -0.0144722001 #> [116] -0.0107257918  0.0487134593  0.0487134593  0.0002546279 -0.0931438608 #> [121] -0.0011345209 -0.0011345209  0.0375753481  0.0062359912  0.0866643452 #> [126]  0.0866643452  0.0866643452  0.0246924924 -0.0187366056 -0.0934362236 #> [131] -0.0603000732 -0.0603000732 -0.0417117852 -0.0074732676 -0.0074732676 #>  #> $l #> [1] 3 #>  #> $m #> [1] 8 #>  #> attr(,\"class\") #> [1] \"nppi\""},{"path":"/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"Select an Optimal Block-Length to Bootstrap Dependent Data (Block Bootstrap)","text":"big shoutout Malina Cheeneebash designing blocklength hex sticker! Also Sergio Armella Simon P. Couch help feedback!","code":""},{"path":"/reference/hhj.html","id":null,"dir":"Reference","previous_headings":"","what":"Hall, Horowitz, and Jing (1995) ","title":"Hall, Horowitz, and Jing (1995) ","text":"Perform Hall, Horowitz, Jing (1995) \"HHJ\" cross-validation algorithm select optimal block-length bootstrap dependent data (block-bootstrap). Dependent data stationary time series suitable usage HHJ algorithm.","code":""},{"path":"/reference/hhj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hall, Horowitz, and Jing (1995) ","text":"","code":"hhj(   series,   nb = 100L,   n_iter = 10L,   pilot_block_length = NULL,   sub_sample = NULL,   k = \"two-sided\",   bofb = 1L,   search_grid = NULL,   grid_step = c(1L, 1L),   cl = NULL,   verbose = TRUE,   plots = TRUE )"},{"path":"/reference/hhj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hall, Horowitz, and Jing (1995) ","text":"series numeric vector time series giving original data find optimal block-length . nb integer value, number bootstrapped series compute. n_iter integer value, maximum number iterations HHJ algorithm compute. pilot_block_length numeric value, block-length (\\(l*\\) HHJ) perform initial block bootstraps. sub_sample numeric value, length overlapping subsample, \\(m\\) HHJ. k character string, either \"bias/variance\", \"one-sided\", \"two-sided\" depending desired object estimation. desired bootstrap statistic bias variance select \"bias/variance\" sets \\(k = 3\\) per HHJ. object estimation one-sided two-sided distribution function, set k = \"one-sided\" k = \"two-sided\" sets \\(k = 4\\) \\(k = 5\\), respectively. purpose generating symmetric confidence intervals around unknown parameter, k = \"two-sided\" (default) used. bofb numeric value, length basic blocks block--blocks bootstrap, see m =  tsbootstrap Kunsch (1989). search_grid numeric value, range solutions around \\(l*\\) evaluate within \\(MSE\\) function first iteration. first iteration search possible block-lengths unless specified grid_step = . grid_step numeric value vector length 2, number steps increment subsample block-lengths evaluating \\(MSE\\) function. grid_step = 1 block-length evaluated \\(MSE\\) function. grid_step > 1, \\(MSE\\) function search sequence block-lengths 1 m grid_step. grid_step vector length 2, first iteration step first element grid_step subsequent iterations step second element. cl cluster object, created package parallel, doParallel, snow. NULL, parallelization used. verbose logical value, set FALSE interim messages output console. Error messages still output. Default TRUE. plots logical value, set FALSE interim plots output console. Default TRUE.","code":""},{"path":"/reference/hhj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hall, Horowitz, and Jing (1995) ","text":"object class 'hhj'","code":""},{"path":"/reference/hhj.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hall, Horowitz, and Jing (1995) ","text":"HHJ algorithm computationally intensive relies cross-validation process using type subsampling estimate mean squared error (\\(MSE\\)) incurred bootstrap various block-lengths. --hood, hhj() makes use tsbootstrap, see Trapletti Hornik (2020), perform moving block-bootstrap (block--blocks bootstrap setting bofb > 1) according Kunsch (1989).","code":""},{"path":"/reference/hhj.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hall, Horowitz, and Jing (1995) ","text":"Adrian Trapletti Kurt Hornik (2020). tseries: Time Series Analysis      Computational Finance. R package version 0.10-48. Kunsch, H. (1989) Jackknife Bootstrap General Stationary      Observations. Annals Statistics, 17(3), 1217-1241. Retrieved      February 16, 2021, doi:10.1214/aos/1176347265 Peter Hall, Joel L. Horowitz, Bing-Yi Jing, blocking rules      bootstrap dependent data, Biometrika, Volume 82, Issue 3,      September 1995, Pages 561-574, DOI: doi:10.1093/biomet/82.3.561","code":""},{"path":"/reference/hhj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hall, Horowitz, and Jing (1995) ","text":"","code":"# \\donttest{ # Generate AR(1) time series sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Calculate optimal block length for series hhj(sim, sub_sample = 10) #>  Pilot block length is: 3 #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo  #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 10 function evaluations required.  #>  Chosen block length: 22  After iteration: 1  #>  Converged at block length (l): 22 #> $`Optimal Block Length` #> [1] 22 #>  #> $`Subsample block size (m)` #> [1] 10 #>  #> $`MSE Data` #>    Iteration BlockLength       MSE #> 1          1           2 0.3392102 #> 2          1           4 0.3505841 #> 3          1           7 0.3549793 #> 4          1           9 0.3639882 #> 5          1          11 0.3567793 #> 6          1          13 0.3727141 #> 7          1          15 0.3616106 #> 8          1          17 0.3607994 #> 9          1          20 0.3435575 #> 10         1          22 0.3248534 #> 11         2           2 0.3442814 #> 12         2           4 0.3555621 #> 13         2           7 0.3639989 #> 14         2           9 0.3704648 #> 15         2          11 0.3637975 #> 16         2          13 0.3786977 #> 17         2          15 0.3682302 #> 18         2          17 0.3668415 #> 19         2          20 0.3475716 #> 20         2          22 0.3282302 #>  #> $Iterations #> [1] 2 #>  #> $Series #> [1] \"sim\" #>  #> $Call #> hhj(series = sim, sub_sample = 10) #>  #> attr(,\"class\") #> [1] \"hhj\"   # Use parallel computing library(parallel)  # Make cluster object with 2 cores cl <- makeCluster(2)  # Calculate optimal block length for series hhj(sim, cl = cl) #>  Pilot block length is: 3 #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 12 function evaluations required.  #>  Chosen block length: 25  After iteration: 1  #>  Converged at block length (l): 25 #> $`Optimal Block Length` #> [1] 25 #>  #> $`Subsample block size (m)` #> [1] 12 #>  #> $`MSE Data` #>    Iteration BlockLength       MSE #> 1          1           2 0.2835706 #> 2          1           4 0.2871580 #> 3          1           6 0.2956577 #> 4          1           8 0.3019145 #> 5          1          11 0.3053446 #> 6          1          13 0.3074474 #> 7          1          15 0.3203711 #> 8          1          17 0.3161137 #> 9          1          19 0.3066318 #> 10         1          21 0.2942307 #> 11         1          23 0.2814262 #> 12         1          25 0.2747927 #> 13         2           2 0.2825282 #> 14         2           4 0.2899254 #> 15         2           6 0.2947477 #> 16         2           8 0.3004585 #> 17         2          11 0.3054337 #> 18         2          13 0.3058513 #> 19         2          15 0.3199239 #> 20         2          17 0.3136037 #> 21         2          19 0.3037068 #> 22         2          21 0.2954288 #> 23         2          23 0.2822465 #> 24         2          25 0.2744703 #>  #> $Iterations #> [1] 2 #>  #> $Series #> [1] \"sim\" #>  #> $Call #> hhj(series = sim, cl = cl) #>  #> attr(,\"class\") #> [1] \"hhj\" # }"},{"path":"/reference/nppi.html","id":null,"dir":"Reference","previous_headings":"","what":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"function implements Nonparametric Plug-(NPPI) algorithm,  proposed Lahiri, Furukawa, Lee (2007), select optimal block  length block bootstrap procedures.  NPPI method estimates optimal block length balancing bias  variance block bootstrap estimators, particularly time series  dependent data structures. function also leverages Moving  Block Bootstrap (MBB) method (Kunsch, 1989) Moving Blocks  Jackknifte (MBJ) Liu Singh (1992).","code":""},{"path":"/reference/nppi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"","code":"nppi(   data,   stat_function = mean,   r = 1,   a = 1,   l = NULL,   m = NULL,   num_bootstrap = 1000,   c_1 = 1L,   epsilon = 1e-08,   plots = TRUE )"},{"path":"/reference/nppi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"data numeric vector, ts, single-column data.frame representing time series dependent data. stat_function function compute statistic interest (*e.g.*, mean, variance). function accept numeric vector input return scalar value (default mean). r rate parameter MSE expansion (default 1). parameter controls convergence rate bias-variance trade-. bias exponent (default 1). Adjust based theoretical properties statistic bootstrapped. l Optional. initial block size bias estimation. provided, set max(2, round(c_1 * n^{1 / (r + 4)})), n sample size. m Optional. number blocks delete Jackknife--Bootstrap (JAB) variance estimation. provided, defaults floor(c_2 * n^{1/3} * l^{2/3}). num_bootstrap number bootstrap replications bias estimation (default 1000). c_1 tuning constant initial block size calculation (default 1). epsilon small constant added variance prevent division zero (default 1e-8). plots logical value indicating whether plot JAB diagnostic","code":""},{"path":"/reference/nppi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"object class nppi following components: optimal_block_length estimated optimal block length    block bootstrap procedure. bias estimated bias block bootstrap estimator. variance estimated variance block bootstrap estimator    using JAB method. jab_point_values point estimates statistic    deletion block JAB variance estimation. Used diagnostic plots l initial block size used bias estimation. m number blocks delete JAB variance estimation. @section References: Efron, B. (1992), 'Jackknife--bootstrap standard errors influence      functions (discussion)', Journal Royal Statistical Society,      Series B 54, 83-111. Kunsch, H. (1989) Jackknife Bootstrap General Stationary      Observations. Annals Statistics, 17(3), 1217-1241. Retrieved      February 16, 2021, doi:10.1214/aos/1176347265 Lahiri, S. N., Furukawa, K., & Lee, Y.-D. (2007). nonparametric plug-     rule selecting optimal block lengths Block Bootstrap Methods.      Statistical Methodology, 4(3), 292-321. DOI:      doi:10.1016/j.stamet.2006.08.002 Lahiri, S. N. (2003). 7.4 Nonparametric Plug-Method. Resampling      methods dependent data (pp. 186-197). Springer. Liu, R. Y. Singh, K. (1992), Moving blocks jackknife bootstrap      capture weak dependence, R. Lepage L. Billard, eds, 'Exploring      Limits Bootstrap', Wiley, New York, pp. 225-248.","code":""},{"path":"/reference/nppi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"Jackknife--Bootstrap (JAB) variance estimation (Lahiri, 2002).","code":""},{"path":"/reference/nppi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lahiri, Furukawa, and Lee (2007) Nonparametric Plug-In ","text":"","code":"# Generate AR(1) time series set.seed(32) sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Estimate the optimal block length for the sample mean result <- nppi(data = sim, stat_function = mean, num_bootstrap = 500, m = 2) #>  Setting l to recomended value: 3   print(result$optimal_block_length) #> [1] 0.0001767721  # Use S3 method to plot JAB diagnostic plot(result)"},{"path":"/reference/plot.hhj.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot MSE Function for HHJ Algorithm — plot.hhj","title":"Plot MSE Function for HHJ Algorithm — plot.hhj","text":"S3 Method objects class 'hhj'","code":""},{"path":"/reference/plot.hhj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot MSE Function for HHJ Algorithm — plot.hhj","text":"","code":"# S3 method for class 'hhj' plot(x, iter = NULL, ...)"},{"path":"/reference/plot.hhj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot MSE Function for HHJ Algorithm — plot.hhj","text":"x object class 'hhj' iter vector hhj() iterations plot. NULL. iterations plotted default. ... Arguments passed base::plot y y coordinates points plot, optional     x appropriate structure.","code":""},{"path":"/reference/plot.hhj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot MSE Function for HHJ Algorithm — plot.hhj","text":"return value, called side effects","code":""},{"path":"/reference/plot.hhj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot MSE Function for HHJ Algorithm — plot.hhj","text":"","code":"# \\donttest{ # Generate AR(1) time series sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Generate 'hhj' class object of optimal block length for series hhj <- hhj(sim, sub_sample = 10) #>  Pilot block length is: 3 #> Performing minimization may take some time #> Calculating MSE for each level in subsample: 10 function evaluations required.  #>  Chosen block length: 22  After iteration: 1  #>  Converged at block length (l): 22  ## S3 method for class 'hhj' plot(hhj)   # }"},{"path":"/reference/plot.nppi.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Stability of JAB Point Estimates — plot.nppi","title":"Plot Stability of JAB Point Estimates — plot.nppi","text":"S3 Method objects class 'nppi' function visualizes JAB point estimates across deletion blocks  indices used estimate variance NPPI algorithm.","code":""},{"path":"/reference/plot.nppi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Stability of JAB Point Estimates — plot.nppi","text":"","code":"# S3 method for class 'nppi' plot(x, ...)"},{"path":"/reference/plot.nppi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Stability of JAB Point Estimates — plot.nppi","text":"x object class nppi, containing JAB point values. ... Arguments passed base::plot y y coordinates points plot, optional     x appropriate structure.","code":""},{"path":"/reference/plot.nppi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Stability of JAB Point Estimates — plot.nppi","text":"return value, called side effects","code":""},{"path":"/reference/plot.nppi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Stability of JAB Point Estimates — plot.nppi","text":"","code":"# Generate AR(1) time series set.seed(32) sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Estimate the optimal block length for the sample mean result <- nppi(data = sim, stat_function = mean, num_bootstrap = 500, m = 2) #>  Setting l to recomended value: 3   # Use s3 method plot(result)"},{"path":"/reference/plot.pwsd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","title":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","text":"S3 Method objects class 'pwsd' See ?plot.acf stats package customization  options correlogram, plot.pwsd based","code":""},{"path":"/reference/plot.pwsd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","text":"","code":"# S3 method for class 'pwsd' plot(x, c = NULL, main = NULL, ylim = NULL, ...)"},{"path":"/reference/plot.pwsd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","text":"x object class 'pwsd' 'acf' c numeric value, constant acts significance level implied hypothesis test. Defaults qnorm(0.975) two-tailed 95% confidence level. Politis  White (2004) suggest c = 2. main overall title plot, string supplied default title  populated. See title ylim numeric length 2 giving y-axis limits plot ... Arguments passed base::plot y y coordinates points plot, optional     x appropriate structure.","code":""},{"path":"/reference/plot.pwsd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","text":"return value, called side effects","code":""},{"path":"/reference/plot.pwsd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Correlogram for Politis and White Auto\\(-\\)Correlation Implied Hypothesis Test — plot.pwsd","text":"","code":"# Use S3 Method  # Generate AR(1) time series sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  b <- pwsd(sim, round = TRUE, correlogram = FALSE) plot(b)"},{"path":"/reference/pwsd.html","id":null,"dir":"Reference","previous_headings":"","what":"Politis and White (2004) Spectral Density ","title":"Politis and White (2004) Spectral Density ","text":"Run Automatic Block-Length selection method proposed Politis White  (2004) corrected Patton, Politis, White (2009). method  based spectral density estimation via flat-top lag windows Politis  Romano (1995). code adapted b.star add  functionality include correlogram support including S3 method,  see Hayfield Racine (2008).","code":""},{"path":"/reference/pwsd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Politis and White (2004) Spectral Density ","text":"","code":"pwsd(   data,   K_N = NULL,   M_max = NULL,   m_hat = NULL,   b_max = NULL,   c = NULL,   round = FALSE,   correlogram = TRUE )"},{"path":"/reference/pwsd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Politis and White (2004) Spectral Density ","text":"data \\(n x k\\) data.frame, matrix, vector (\\(k = 1\\)) optimal block-length computed \\(k\\) columns. K_N integer value, maximum lags auto-correlation, \\(rho_k\\), apply implied hypothesis test. Defaults max(5, log(N)). See Politis White (2004) footnote c. M_max integer value, upper-bound optimal number lags, \\(M\\), compute auto-covariance . See Theorem 3.3 (ii) Politis White (2004). m_hat integer value, set NULL (default), m_hat estimated smallest integer correlogram appears negligible K_N lags. problematic cases, setting m_hat integer value can used override estimation procedure. b_max numeric value, upper-bound optimal block-length. Defaults ceiling(min(3 * sqrt(n), n / 3)) per Politis White (2004). c numeric value, constant acts significance level implied hypothesis test. Defaults qnorm(0.975) two-tailed 95% confidence level. Politis  White (2004) suggest c = 2. round logical value, set FALSE final block-length output rounded, default. set TRUE final estimates optimal block-length rounded whole numbers. correlogram logical value, set TRUE plot correlogram (.e. plot \\(R(k)\\) vs. \\(k\\)) output console. set FALSE, interim plots output console, may plotted later using corresponding S3 method, plot.pwsd.","code":""},{"path":"/reference/pwsd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Politis and White (2004) Spectral Density ","text":"object class 'pwsd'","code":""},{"path":"/reference/pwsd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Politis and White (2004) Spectral Density ","text":"Andrew Patton, Dimitris N. Politis & Halbert White (2009) Correction      \"Automatic Block-Length Selection Dependent Bootstrap\" D.      Politis H. White, Econometric Review, 28:4, 372-375, DOI:      doi:10.1080/07474930802459016 Dimitris N. Politis & Halbert White (2004) Automatic Block-Length Selection      Dependent Bootstrap, Econometric Reviews, 23:1, 53-70, DOI:      doi:10.1081/ETC-120028836 Politis, D.N. Romano, J.P. (1995), Bias-Corrected Nonparametric Spectral      Estimation. Journal Time Series Analysis, 16: 67-103, DOI:      doi:10.1111/j.1467-9892.1995.tb00223.x Tristen Hayfield Jeffrey S. Racine (2008). Nonparametric Econometrics:      np Package. Journal Statistical Software 27(5). DOI:      doi:10.18637/jss.v027.i05","code":""},{"path":"/reference/pwsd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Politis and White (2004) Spectral Density ","text":"","code":"# Generate AR(1) time series sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),                         n = 500, innov = rnorm(500))  # Calculate optimal block length for series pwsd(sim, round = TRUE)  #> $BlockLength #>      b_Stationary b_Circular #> data            8          9 #>  #> $Acf #> $Acf$data #>  #> Autocorrelations of series ‘data[, i]’, by lag #>  #>      0      1      2      3      4      5      6      7      8      9     10  #>  1.000  0.491  0.277  0.127  0.041  0.040  0.010 -0.019  0.000  0.048  0.067  #>     11     12     13     14     15     16     17     18     19     20     21  #>  0.049  0.032  0.039 -0.004 -0.049 -0.040 -0.040 -0.018  0.041  0.019  0.047  #>     22     23     24     25     26     27     28  #> -0.023 -0.049 -0.061 -0.059 -0.024 -0.032 -0.069  #>  #>  #> $parameters #>        n k        c K_N M_max b_max m_hat M rho_k_critical #> [1,] 500 1 1.959964   5    28    68     2 4      0.1439999 #>  #> $Call #> pwsd(data = sim, round = TRUE) #>  #> attr(,\"class\") #> [1] \"pwsd\"   # Use S3 Method b <- pwsd(sim, round = TRUE, correlogram = FALSE) plot(b)"},{"path":"/news/index.html","id":"blocklength-020","dir":"Changelog","previous_headings":"","what":"blocklength 0.2.0","title":"blocklength 0.2.0","text":"CRAN release: 2025-02-17","code":""},{"path":"/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"blocklength 0.2.0","text":"new function nppi() added package. function estimates optimal block-length using non-parametric plug-(NPPI) method Lahiri, Furukawa, Lee, (2007). new S3 plot method plot.nppi() added package. function outputs diagnostic plot JAB point values calculated nppi() function.","code":""},{"path":"/news/index.html","id":"blocklength-015","dir":"Changelog","previous_headings":"","what":"blocklength 0.1.5","title":"blocklength 0.1.5","text":"CRAN release: 2022-03-02 Minor adjustments documentation per CRAN requests.","code":""},{"path":"/news/index.html","id":"blocklength-014","dir":"Changelog","previous_headings":"","what":"blocklength 0.1.4","title":"blocklength 0.1.4","text":"CRAN release: 2021-05-12","code":""},{"path":"/news/index.html","id":"bug-fixes-0-1-4","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"blocklength 0.1.4","text":"pwsd(), m_hat indexing first insignificant lag correlation structure rather first significant lag prior consecutive run insignificant lags. pwsd() plot.pwsd() now output significance bands match rho_k_critical exactly. Prior , significance bands correlogram output generated using plot.acf(ci = ) argument led misleading graphical representations implied hypothesis test’s critical value PWSD method. hhj(), sub_block_length changed sub_sample avoid confusion tuning parameter, pilot_block_length","code":""},{"path":"/news/index.html","id":"minor-changes-0-1-4","dir":"Changelog","previous_headings":"","what":"Minor Changes","title":"blocklength 0.1.4","text":"new vignette included tuning diagnosing problematic output selection functions! pwsd() now includes new argument override implied hypothesis test setting m_hat directly. pwsd(), rho.k.critical changed snake case rho_k_critical $parameters matrix output class ‘pwsd’ objects pwsd(). hhj(), subsample = set directly now rounded nearest whole number. plot.pwsd() now includes “darkmagenta” significance lines match pwsd(). plot.pwsd() now explicitly includes option customize title main = . hhj() now includes warning message supplied iteration limit n_iter reached still outputs object class ‘hhj.’","code":""},{"path":"/news/index.html","id":"blocklength-013","dir":"Changelog","previous_headings":"","what":"blocklength 0.1.3","title":"blocklength 0.1.3","text":"CRAN release: 2021-02-25 first submission accepted CRAN Minor changes documentation testing examples","code":""},{"path":"/news/index.html","id":"blocklength-010","dir":"Changelog","previous_headings":"","what":"blocklength 0.1.0","title":"blocklength 0.1.0","text":"first submission blocklength package.","code":""}]
