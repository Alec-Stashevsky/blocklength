% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hhj.R, R/hhjboot.R
\name{hhj}
\alias{hhj}
\title{Hall, Horowitz, and Jing (1995) "HHJ" Algorithm to Select Optimal Block-Length}
\usage{
hhj(
  series,
  nb = 100L,
  n_iter = 10L,
  pilot_block_length = NULL,
  sub_block_length = NULL,
  bofb = 1L,
  search_grid = NULL,
  grid_step = c(1L, 1L),
  cl = NULL,
  verbose = TRUE,
  plots = TRUE
)

hhj(
  series,
  nb = 100L,
  n_iter = 10L,
  pilot_block_length = NULL,
  sub_block_length = NULL,
  bofb = 1L,
  search_grid = NULL,
  grid_step = c(1L, 1L),
  cl = NULL,
  verbose = TRUE,
  plots = TRUE
)
}
\arguments{
\item{series}{a numeric vector or time series giving the original data for
which to find the optimal block length for.}

\item{nb}{an integer value, number of bootstrap series to compute.}

\item{n_iter}{an integer value, maximum number of iterations for HHJ algorithm.}

\item{pilot_block_length}{a numeric value, pilot block length (\eqn{l*}
\emph{in HHJ}) for which to perform initial block bootstraps.}

\item{sub_block_length}{a numeric value, the length of each overlapping
subsample (\eqn{m} \emph{in HHJ}).}

\item{bofb}{a numeric value, length of the basic blocks in the
\emph{block-of-blocks} bootstrap. \emph{See} \code{m =} for
\code{\link[tseries]{tsbootstrap}}.}

\item{search_grid}{a numeric value, the range of solutions around l* to
evaluate within the MSE function \emph{after} 1st iteration.}

\item{grid_step}{a numeric value, the number to increment over subsample block
lengths. If \code{grid_step = 1} then each block length will be evaluated in
the MSE function, if \code{grid_step > 1}, the the MSE function will search
over the sequence of block-lengths from \code{1} to \code{m} by
\code{grid_step}. If \code{grid_step} is supplied as a vector of length 2,
the the first iteration will step by the first element and subsequent
iterations will step by the second element.}

\item{cl}{a cluster object, created by package \pkg{parallel},
\pkg{doParallel} or by package \pkg{snow}. If \code{NULL}, no parallelization
will be used.}

\item{verbose}{a logical value, if set to \code{FALSE} then no interim
messages are output to the console. Error messages will still be output.
Default is \code{TRUE}.}

\item{plots}{a logical value, if set to \code{FALSE} then no interim
plots are output to the console. Default is \code{TRUE}.}
}
\value{
an object of class 'hhj'

an object of class 'hhj'
}
\description{
Perform the Hall, Horowitz, and Jing (1995) "HHJ" cross-validation algorithm
to select the optimal block-length \eqn{(l)} for a block bootstrap. Dependent
data such as stationary time series are suitable for usage with the HHJ algorithm.

Perform the Hall, Horowitz, and Jing (1995) "HHJ" cross-validation algorithm
to select the optimal block-length \eqn{(l)} for a block bootstrap. Dependent
data such as stationary time series are suitable for usage with the HHJ algorithm.
}
\details{
The HHJ algorithm is computationally intensive as it relies on a cross-validation
process using a type of subsampling to estimate the mean squared error,
(\eqn{MSE}), incurred by the bootstrap at various block-lengths.

Under-the-hood, \code{hhj} makes use of \code{\link[tseries]{tsbootstrap}}
(\emph{See} Trapletti and Hornik (2020)) to perform the moving block-bootstrap
(or the \emph{block-of-blocks} bootstrap by setting \code{bofb > 1}) according
to Künsch (1989).

The HHJ algorithm is computationally intensive as it relies on a cross-validation
process using a type of subsampling to estimate the mean squared error,
(\eqn{MSE}), incurred by the bootstrap at various block-lengths.

Under-the-hood, \code{hhj} makes use of \code{\link[tseries]{tsbootstrap}}
(\emph{See} Trapletti and Hornik (2020)) to perform the moving block-bootstrap
(or the \emph{block-of-blocks} bootstrap by setting \code{bofb > 1}) according
to Künsch (1989).
}
\section{References}{


Adrian Trapletti and Kurt Hornik (2020). tseries: Time Series Analysis and
 Computational Finance. R package version 0.10-48.

Künsch, H. (1989). The Jackknife and the Bootstrap for General Stationary
 Observations. The Annals of Statistics, 17(3), 1217-1241. Retrieved
 February 16, 2021, from \url{http://www.jstor.org/stable/2241719}

Peter Hall, Joel L. Horowitz, Bing-Yi Jing, On blocking rules for the
 bootstrap with dependent data, Biometrika, Volume 82, Issue 3, September
 1995, Pages 561–574, \url{https://doi.org/10.1093/biomet/82.3.561#'}



Adrian Trapletti and Kurt Hornik (2020). tseries: Time Series Analysis and
 Computational Finance. R package version 0.10-48.

Künsch, H. (1989). The Jackknife and the Bootstrap for General Stationary
 Observations. The Annals of Statistics, 17(3), 1217-1241. Retrieved
 February 16, 2021, from \url{http://www.jstor.org/stable/2241719}

Peter Hall, Joel L. Horowitz, Bing-Yi Jing, On blocking rules for the
 bootstrap with dependent data, Biometrika, Volume 82, Issue 3, September
 1995, Pages 561–574, \url{https://doi.org/10.1093/biomet/82.3.561#'}
}

\examples{
# Generate AR(1) time series
sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Calculate optimal block length for series
hhj(sim, sub_block_length = 10)

\dontrun{
# Use parallel computing
library(parallel)

# Make cluster object with all cores available
cl <- makeCluster(detectCores())

# Calculate optimal block length for series
hhj(sim, cl = cl)
}

# Generate AR(1) time series
sim <- stats::arima.sim(list(order = c(1, 0, 0), ar = 0.5),
                        n = 500, innov = rnorm(500))

# Calculate optimal block length for series
hhj(sim, sub_block_length = 10)

\dontrun{
# Use parallel computing
library(parallel)

# Make cluster object with all cores available
cl <- makeCluster(detectCores())

# Calculate optimal block length for series
hhj(sim, cl = cl)
}

}
